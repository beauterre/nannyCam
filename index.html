<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>System Monitor</title>
<style>
body {
    margin: 0;
    background: black;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}
#startBtn {
    position: absolute;
    z-index: 10;
    padding: 15px 30px;
    font-size: 18px;
    cursor: pointer;
}
#coverImage {
    display: none;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
}
video {
    display: none;
}
canvas {
    display: none;
}
</style>
</head>
<body>

<button id="startBtn">Start Nanny Cam v202602151238</button>
<img id="coverImage" src="inconspicuous.png" />

<video id="video" autoplay playsinline></video>
<canvas id="captureCanvas"></canvas>

<script>
const video = document.getElementById("video");
const startBtn = document.getElementById("startBtn");
const coverImage = document.getElementById("coverImage");

const captureCanvas = document.getElementById("captureCanvas");
const captureCtx = captureCanvas.getContext("2d");

// --- Detection configuration ---
const DETECT_WIDTH = 32;
const MOTION_THRESHOLD = 10;
const MOTION_BLOCK_TRIGGER = 6;
const BG_LEARN_RATE = 0.04;

let detectCanvas = document.createElement("canvas");
let detectCtx = detectCanvas.getContext("2d");
let detectHeight = 0;
let backgroundModel = null;

let folderHandle = null;
let wakeLock = null;
let lastSaveTime = 0;

const SAVE_COOLDOWN = 3000;
const BURST_COUNT = 5;
const BURST_INTERVAL = 200;

const BRIGHTNESS_BOOST = 1.4;
const CONTRAST = 1.2;

const writeQueue = [];

// ---------- Safe file writer ----------
async function safeWriteFile(filename, blob) {
    try {
        const fileHandle = await folderHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
    } catch (err) {
        const perm = await folderHandle.queryPermission({ mode: "readwrite" });
        if (perm === "granted") {
            const fileHandle = await folderHandle.getFileHandle(filename, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
        }
    }
}

// ---------- Background writer loop ----------
async function writerLoop() {
    while(true) {
        if(writeQueue.length > 0) {
            const item = writeQueue.shift();
            await safeWriteFile(item.filename, item.blob);
        } else {
            await new Promise(r => setTimeout(r, 100));
        }
    }
}
writerLoop();

// ---------- Start ----------
startBtn.addEventListener("click", async () => {
    try {

        folderHandle = await window.showDirectoryPicker({ mode: "readwrite" });

        await document.documentElement.requestFullscreen();

        if('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
        }

        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;

        startBtn.style.display = "none";
        coverImage.style.display = "block";

        video.onloadedmetadata = () => {

            // Full resolution capture canvas
            captureCanvas.width = video.videoWidth;
            captureCanvas.height = video.videoHeight;

            // Detection canvas setup
            const aspect = video.videoHeight / video.videoWidth;
            detectHeight = Math.floor(DETECT_WIDTH * aspect);

            detectCanvas.width = DETECT_WIDTH;
            detectCanvas.height = detectHeight;

            detectMotion();
        };

    } catch(err) {
        alert("Permissions required.");
    }
});

// ---------- Motion Detection ----------
function detectMotion() {

    detectCtx.drawImage(video, 0, 0, DETECT_WIDTH, detectHeight);
    const frame = detectCtx.getImageData(0, 0, DETECT_WIDTH, detectHeight);
    const data = frame.data;
    const pixelCount = DETECT_WIDTH * detectHeight;

    if (!backgroundModel) {
        backgroundModel = new Float32Array(pixelCount);
        for (let i = 0, j = 0; i < data.length; i += 4, j++) {
            backgroundModel[j] =
                0.3 * data[i] +
                0.59 * data[i + 1] +
                0.11 * data[i + 2];
        }
        requestAnimationFrame(detectMotion);
        return;
    }

    let blockChanges = 0;
    const blockSize = 4;

    for (let by = 0; by < detectHeight; by += blockSize) {
        for (let bx = 0; bx < DETECT_WIDTH; bx += blockSize) {

            let blockMotion = 0;

            for (let y = 0; y < blockSize; y++) {
                for (let x = 0; x < blockSize; x++) {

                    const px = bx + x;
                    const py = by + y;
                    if (px >= DETECT_WIDTH || py >= detectHeight) continue;

                    const index = py * DETECT_WIDTH + px;
                    const i = index * 4;

                    const brightness =
                        0.3 * data[i] +
                        0.59 * data[i + 1] +
                        0.11 * data[i + 2];

                    const diff = Math.abs(brightness - backgroundModel[index]);

                    if (diff > MOTION_THRESHOLD) {
                        blockMotion++;
                    }

                    // Update background model
                    backgroundModel[index] =
                        backgroundModel[index] * (1 - BG_LEARN_RATE) +
                        brightness * BG_LEARN_RATE;
                }
            }

            if (blockMotion > 2) {
                blockChanges++;
            }
        }
    }

    if (blockChanges > MOTION_BLOCK_TRIGGER) {
        const now = Date.now();
        if (now - lastSaveTime > SAVE_COOLDOWN) {
            lastSaveTime = now;
            captureBurst();
        }
    }

    requestAnimationFrame(detectMotion);
}

// ---------- Capture burst ----------
async function captureBurst() {
    for(let i=0; i<BURST_COUNT; i++) {
        const blob = await getCanvasBlob();
        const filename = generateFilename(i);
        writeQueue.push({ filename, blob });
        await new Promise(r => setTimeout(r, BURST_INTERVAL));
    }
}

// ---------- Full resolution capture ----------
async function getCanvasBlob() {

    captureCtx.drawImage(video, 0, 0);

    const imageData = captureCtx.getImageData(
        0, 0,
        captureCanvas.width,
        captureCanvas.height
    );

    const data = imageData.data;

    for(let i=0; i<data.length; i+=4){

        data[i] *= BRIGHTNESS_BOOST;
        data[i+1] *= BRIGHTNESS_BOOST;
        data[i+2] *= BRIGHTNESS_BOOST;

        data[i] = ((data[i]-128)*CONTRAST)+128;
        data[i+1] = ((data[i+1]-128)*CONTRAST)+128;
        data[i+2] = ((data[i+2]-128)*CONTRAST)+128;

        data[i] = Math.min(255, Math.max(0, data[i]));
        data[i+1] = Math.min(255, Math.max(0, data[i+1]));
        data[i+2] = Math.min(255, Math.max(0, data[i+2]));
    }

    captureCtx.putImageData(imageData, 0, 0);

    return new Promise(resolve => captureCanvas.toBlob(resolve, "image/png"));
}

// ---------- Timestamp filename ----------
function generateFilename(burstIndex){
    const now = new Date();
    const ts =
        now.getFullYear() + "-" +
        String(now.getMonth()+1).padStart(2,'0') + "-" +
        String(now.getDate()).padStart(2,'0') + "_" +
        String(now.getHours()).padStart(2,'0') + "-" +
        String(now.getMinutes()).padStart(2,'0') + "-" +
        String(now.getSeconds()).padStart(2,'0') + "-" +
        String(now.getMilliseconds()).padStart(3,'0');
    return `${ts}_burst${burstIndex}.png`;
}

// ---------- Wake lock release ----------
document.addEventListener("fullscreenchange", () => {
    if(!document.fullscreenElement && wakeLock){
        wakeLock.release();
    }
});
</script>

</body>
</html>
