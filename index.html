<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>System Monitor</title>
<style>
body {
    margin: 0;
    background: black;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}
#startBtn {
    position: absolute;
    z-index: 10;
    padding: 15px 30px;
    font-size: 18px;
    cursor: pointer;
}
#coverImage {
    display: none;
    width: 100vw;
    height: 100vh;
    object-fit: cover;
}
video, canvas {
    display: none;
}
</style>
</head>
<body>

<button id="startBtn">Start Nanny Cam v202602151225</button>
<img id="coverImage" src="inconspicuous.png" />

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const startBtn = document.getElementById("startBtn");
const coverImage = document.getElementById("coverImage");

let previousFrame = null;
let folderHandle = null;
let wakeLock = null;
let lastSaveTime = 0;

const SAVE_COOLDOWN = 3000; // 3 seconds
const BURST_COUNT = 5;
const BURST_INTERVAL = 200; // ms between burst shots

const BRIGHTNESS_BOOST = 1.4;
const CONTRAST = 1.2;

// Memory queue for safe background writes
const writeQueue = [];

// ---------- Safe file writer ----------
async function safeWriteFile(filename, blob) {
    try {
        const fileHandle = await folderHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(blob);
        await writable.close();
    } catch (err) {
        console.warn("Write blocked, retrying permission check...");
        const perm = await folderHandle.queryPermission({ mode: "readwrite" });
        if (perm === "granted") {
            const fileHandle = await folderHandle.getFileHandle(filename, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
        } else {
            console.error("Permission lost.");
        }
    }
}

// ---------- Background writer loop ----------
async function writerLoop() {
    while(true) {
        if(writeQueue.length > 0) {
            const item = writeQueue.shift();
            await safeWriteFile(item.filename, item.blob);
        } else {
            await new Promise(r => setTimeout(r, 100));
        }
    }
}
writerLoop();

// ---------- Click handler ----------
startBtn.addEventListener("click", async () => {
    try {
        folderHandle = await window.showDirectoryPicker({
            mode: "readwrite"
        });

        await document.documentElement.requestFullscreen();

        if('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
        }

        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;

        startBtn.style.display = "none";
        coverImage.style.display = "block";

        video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            detectMotion();
        };
    } catch(err) {
        alert("Permissions required.");
        console.error(err);
    }
});

// ---------- Motion detection (1px) ----------
async function detectMotion() {
    ctx.drawImage(video, 0, 0, 1, 1);
    const frame = ctx.getImageData(0, 0, 1, 1);
    const data = frame.data;

    const brightness = 0.3*data[0] + 0.59*data[1] + 0.11*data[2];

    if(previousFrame !== null) {
        const change = Math.abs(brightness - previousFrame);
        if(change > 8) {
            const now = Date.now();
            if(now - lastSaveTime > SAVE_COOLDOWN) {
                lastSaveTime = now;
                captureBurst();
            }
        }
    }

    previousFrame = brightness;
    requestAnimationFrame(detectMotion);
}

// ---------- Capture burst ----------
async function captureBurst() {
    for(let i=0; i<BURST_COUNT; i++) {
        const blob = await getCanvasBlob();
        const filename = generateFilename(i);
        writeQueue.push({ filename, blob });
        await new Promise(r => setTimeout(r, BURST_INTERVAL));
    }
}

// ---------- Grab canvas + apply low-light boost ----------
async function getCanvasBlob() {
    ctx.drawImage(video, 0, 0);

    const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = imageData.data;

    for(let i=0; i<data.length; i+=4){
        // Brightness
        data[i] *= BRIGHTNESS_BOOST;
        data[i+1] *= BRIGHTNESS_BOOST;
        data[i+2] *= BRIGHTNESS_BOOST;

        // Contrast
        data[i] = ((data[i]-128)*CONTRAST)+128;
        data[i+1] = ((data[i+1]-128)*CONTRAST)+128;
        data[i+2] = ((data[i+2]-128)*CONTRAST)+128;

        // Clamp
        data[i] = Math.min(255, Math.max(0, data[i]));
        data[i+1] = Math.min(255, Math.max(0, data[i+1]));
        data[i+2] = Math.min(255, Math.max(0, data[i+2]));
    }

    ctx.putImageData(imageData, 0, 0);

    return new Promise(resolve => canvas.toBlob(resolve, "image/png"));
}

// ---------- Generate timestamp filename ----------
function generateFilename(burstIndex){
    const now = new Date();
    const ts =
        now.getFullYear() + "-" +
        String(now.getMonth()+1).padStart(2,'0') + "-" +
        String(now.getDate()).padStart(2,'0') + "_" +
        String(now.getHours()).padStart(2,'0') + "-" +
        String(now.getMinutes()).padStart(2,'0') + "-" +
        String(now.getSeconds()).padStart(2,'0') + "-" +
        String(now.getMilliseconds()).padStart(3,'0');
    return `${ts}_burst${burstIndex}.png`;
}

// ---------- Wake lock release on exit fullscreen ----------
document.addEventListener("fullscreenchange", () => {
    if(!document.fullscreenElement && wakeLock){
        wakeLock.release();
    }
});
</script>

</body>
</html>
